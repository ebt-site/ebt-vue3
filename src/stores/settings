import { defineStore } from 'pinia';
import { logger } from 'log-instance';
import Utils from "../utils.mjs";
import { default as Settings } from "../../src/ebt-settings.mjs";
import { default as EbtCard } from "../../src/ebt-card.mjs";

var id = 1;

function elementInViewport(elt) {
  const root = document.documentElement;
  const rect = elt?.getBoundingClientRect();
  return rect?.top >= 0 && rect?.left >= 0 &&
    rect?.bottom <= (window.innerHeight || root.clientHeight) &&
    rect?.right <= (window.innerWidth || root.clientWidth)
}

export const useSettingsStore = defineStore('settings', {
  state: () => {
    let s = Object.assign({}, Settings.INITIAL_STATE);
    s.id = id++;
    let savedState = localStorage.settings;
    if (savedState) {
      try {
        savedState = JSON.parse(savedState);
        let { cards, logLevel } = savedState;
        logger.logLevel = logLevel;
        if (cards == null) {
          cards = savedState.cards = [{}];
        }
        cards.forEach((card,i) => {
          cards[i] = new EbtCard(card);
        });
      } catch(e) {
        logger.error(`SettingsStore.state() corrupt localStorage`, 
          savedState, e.message);
        savedState = null;
      }
    }
    if (savedState) {
      Utils.assignTyped(s, savedState, Settings.INITIAL_STATE);
      s.cards = savedState.cards;
    }
    logger.debug(`SettingsStore.state() => `, s);
    return s;
  },
  actions: {
    saveSettings() {
      let saved = Utils.assignTyped({}, this, Settings.INITIAL_STATE);
      saved.cards = this.cards;
      logger.logLevel = saved.logLevel;
      let json = JSON.stringify(saved);
      localStorage.settings = json;
      logger.debug("SettingsStore.saveSettings() localStorage.settings", 
        localStorage.settings);
    },
    removeCard(card) {
      this.cards = this.cards.filter(c => c !== card);
    },
    addCard(opts) {
      let { cards, langTrans } = this;
      let { context, location } = opts;
      switch (context) {
        case EbtCard.CONTEXT_SEARCH:
        case EbtCard.CONTEXT_SUTTA:
        case EbtCard.CONTEXT_HOME:
        case EbtCard.CONTEXT_WIKI:
          logger.info("addCard", {context, location, langTrans});
          let card = new EbtCard(Object.assign({langTrans}, opts));
          this.cards.push(card);
          return card;
        default:
          logger.info("addCard => null [INVALID CONTEXT]", opts);
          return null;
      }
    },
    moveCard(srcIndex, dstIndex) {
      let { cards } = this;
      let srcCard = cards[srcIndex];
      cards.splice(srcIndex, 1);
      cards.splice(dstIndex, 0, srcCard);
    },
    scrollToElementId(id) {
      let elt = document.getElementById(id);
      if (elementInViewport(elt)) {
        logger.info(`settings.scrollToElementId(${id}) is visible`, {elt, id} );
        return false; // element already visible (no scrolling)
      }

      logger.info(`settings.scrollToElementId(${id}) not visible`, {elt, id} );
      elt?.scrollIntoView({
        block: "start",
        behavior: "smooth",
      });
      return true; // element originally not in viewport
    },
    clear() {
      delete localStorage.settings;
      Utils.assignTyped(this, Settings.INITIAL_STATE);
      logger.debug(`SettingsStore.clear()`, this);
    },
    suttaRefUrl(suttaRef) {
      let search = encodeURIComponent(suttaRef.toString());
      let { serverUrl } = this;
      return [ serverUrl, 'search', search, ].join('/');
    },
    async fetchSutta(suttaRef) {
      let url = this.suttaRefUrl(suttaRef);
      logger.info("volatile.fetchSutta()", {suttaRef, url});
      let sutta;
      return sutta;
    },
  },
  getters: {
    development(state) {
      let { logLevel } = state;
      return logLevel === 'debug' || logLevel === 'info';
    },
    cardsOpen: (state)=>{
      let { cards } = state;
      return cards.reduce((a,v)=> (v.isOpen ? a+1: a), 0);
    },
    servers: (state)=>{ 
      let isDev = window.location.host.startsWith('localhost');;
      let servers = Settings.SERVERS.filter(svr => !svr.dev || isDev);
      return servers;
    },
    server: (state)=>{
      return state.servers.reduce((a,v) => {
        return v.value === state.serverUrl ? v : a;
      }, "unknown");
    },
  },

})
