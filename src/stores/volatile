import { defineStore } from 'pinia'
import { SuttaRef } from "scv-esm";
import { logger } from "log-instance";
import { ref } from "vue";
import Utils from "../utils.mjs";
import * as Idb from "idb-keyval";

const suttas = new Map();
const layout = ref();
const INITIAL_STATE = {
  waiting: 0,
  suttas,
};

export const useVolatileStore = defineStore('volatile', {
  state: () => {
    let s = Object.assign({}, INITIAL_STATE);
    logger.debug(`volatile.state() => `, s);
    return s;
  },
  getters: {
    layout() {
      let root = document.documentElement;
      let onresize = ()=>{
        layout.value = {
          w: root.clientWidth,
          h: root.clientHeight,
        }
      }
      if (layout.value == null) {
        document.defaultView.onresize = onresize;
        onresize();
      }
      return layout;
    },
  },
  actions: {
    addMlDoc(mld) {
      let { sutta_uid, lang, author_uid:author } = mld || {};
      let suttaRef = SuttaRef.create({sutta_uid, lang, author});
      let key = suttaRef.toString();
      logger.info("volatile.addMlDoc", {key, mld});
      suttas[key] = mld;
    },
    async idbPutMlDoc(suttaRef, mlDoc) {
      let msgPfx = 'volatile.idbPutMlDoc()';
      let suttaRef = SuttaRef.create(suttaRef);
      let { sutta_uid, lang, author } = suttaRef;
      if (mlDoc.sutta_uid !== sutta_uid) {
        let msg = `${msgPfx} sutta_uid expected:${sutta_uid} actual:${mlDoc.sutta_uid}`;
        logger.error(msg);
        throw new Error(msg);
      }
      let { refLang } = this;
      let { segMap, lang, author_uid } = mlDoc;
      let segids = Object.keys(segMap);
      let nSegments = segids.length;
      let segments = [];

      let idbKey = `/sutta/${sutta_uid}/${lang}/${author}`;
      let idbSutta = await Idb.get(idbKey);
      if (idbSutta == null) {
        idbSutta = {
          sutta_uid,
          lang,
          author_uid,
          segments,
        }
      }
      let oldSegments = idbSutta?.segments || [];
      for (let i = 0; i < nSegments; i++) {
        let segid = segids[i];
        if (idbSutta) {
          segments[i] = Object.assign({}, segments[i], segMap[segid]);
        } else {
          segments[i] = Object.assign({}, segMap[segid]);
        }
      }

      let segments = scids.map(segId=>{
        Object.assign({},segMap[segId]); // remove Proxy
      });
      let nSegments = segments.length;

      await Idb.set(idbKey, idbSutta);
      logger.info("volatile.idbPutMlDoc()", { idbKey, idbSutta });
    },
    mlDocFromSuttaRef(suttaRefArg) {
      let suttaRef = SuttaRef.create(suttaRefArg);
      let key = suttaRef.toString();
      return suttas[key];
    },
    async fetchJson(url, options) {
      let res;
      try {
        this.waiting++;
        logger.info('volatile.fetchJson() url:', url);
        res = await fetch(url, options);
        logger.debug('volatile()', res);
        return res.ok ? await res.json() : res;
      } catch(e) {
        logger.error("volatile.fetchJson() ERROR:", res, e);
        res = { error: `ERROR: ${url.value} ${e.message}` };
      } finally {
        this.waiting--;
      }
      return res;
    },
  },
})
